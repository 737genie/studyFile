문제 설명
인터넷 세계의 '밈군주'이자 은하계 최고의 효율을 자랑하는 시공간 우체부, 
급하냥은 오늘도 바쁩니다. 그의 초광속 우주선 '익스프레스 냥호'는 
차원을 넘나들며 소포를 배달하죠. 문제는 그의 소포 관리 시스템이 
너무나도 원시적이라는 것입니다. 
바로 우주선 계기판에 포스트잇을 붙여놓는 것이죠!

"어휴, 답답해! '쥐라기 시대 티라노사우루스 앞'으로 가는 소포가 
왜 '5차원 젤리곰 왕국'에 가 있냐고!"

포스트잇은 웜홀을 지날 때마다 떨어지기 일쑤고, 
어제 배달 완료한 소포가 뭔지, 오늘 배달할 소포가 어딨는지 찾다가 
시간을 다 보냅니다. 효율의 화신인 급하냥은 이 구식 시스템에 분노가 
폭발하기 일보 직전입니다.

"이따위 비효율적인 시스템은 참을 수 없다냥! 
당장 소포를 체계적으로 관리할 웹 애플리케이션을 만들어라, 인간!"

성격 급한 급하냥이 당신에게 '초차원 소포 관리 시스템' 개발을 명령했습니다. 
그의 요구사항은 명료하고 간단합니다.

소포 접수: 새로운 소포의 발신인, 수신인, 목적지(차원/행성), 내용물, 그리고 현재 상태('접수 대기')를 등록할 수 있어야 합니다.

소포 목록 확인: 접수된 모든 소포의 목록을 한눈에 볼 수 있어야 합니다.

소포 상태 변경: 소포의 배송 상태를 변경할 수 있어야 합니다. 
(예: '접수 대기' -> '배송 중' -> '배달 완료')

배송 완료 처리: 배달이 완벽하게 끝난 소포는 기록에서 삭제하여 
목록을 깔끔하게 유지해야 합니다.

당신의 임무는 급하냥의 전속 개발자가 되어, 
이 요구사항을 스프링 부트와 JPA를 이용해 구현하는 것입니다. 
View 단(HTML)과 기본 DTO, Entity는 제가 또 미리 만들어 두었습니다. 
당신은 Controller, Service, Repository의 핵심 로직을 채워 급하냥의 
배송 효율을 빛의 속도로 끌어올려 주세요!

핵심 개념
Spring Boot: 기본적인 애플리케이션 설정

Spring MVC: @Controller, @GetMapping, @PostMapping, @PathVariable, Model 객체

Spring Data JPA: JpaRepository 인터페이스를 활용한 DB CRUD 연산

Thymeleaf: 템플릿 엔진

Enum Type: 배송 상태(Status)와 같이 정해진 값들을 관리하기 위한 열거형 타입 활용

자연어 설계 / 아키텍처 설계
1단계: 자연어 설계 (급하냥이 신입에게 내리는 업무 지시)
"정신 바짝 차리고 들어라냥! 시간은 금이다!"

소포 접수:

사용자가 '새 소포 접수' 버튼을 누르면, 빈 접수 폼(new-parcel-form.html)을 1초 안에 보여줘.

사용자가 폼을 다 채우고 '접수!' 버튼을 누르면, 데이터는 ParcelController가 받아. 꾸물거리지 마!

Controller는 받은 데이터를 ParcelService에게 "이거 당장 시스템에 등록해!"라고 던져줘.

Service는 데이터를 Parcel 엔티티로 변환해서, ParcelRepository에게 "데이터베이스에 저장해, 지금 당장!"이라고 명령해.

저장 끝나면, 바로 전체 소포 목록 페이지(/parcels)로 이동시켜서 방금 등록한 소포를 확인하게 해. 1나노초의 딜레이도 용납 못 한다냥.

목록 조회:

사용자가 소포 목록 페이지(/parcels)에 들어오면, Controller는 Service에게 "모든 소포 목록, 최대한 빨리 가져와!"라고 재촉해.

Service는 Repository를 시켜 DB의 모든 소포를 가져와 Controller에게 전달.

Controller는 받은 목록을 Model에 담아 목록 페이지(list.html)에 뿌려줘. 로딩은 0.1초를 넘기면 안 돼.

상태 변경 및 삭제:

목록에서 특정 소포를 클릭하면, 그 소포의 ID를 주소에 달고( /parcels/{id}/edit) 수정 페이지로 이동해.

수정 페이지(edit-form.html)에서 배송 상태를 바꾸고 '수정!' 버튼을 누르면, Controller -> Service -> Repository 순으로 DB에 업데이트 요청을 보내.

'배송 완료 처리' 버튼을 누르면, 해당 소포 ID를 Controller에게 보내고, Service를 통해 Repository에게 "이거 기록에서 지워버려!"라고 하면 끝. 간단하지?

2단계: 아키텍처 청사진 (설계도 그리기)
presentation Layer (Controller)

ParcelController.java: 웹 브라우저의 요청을 받아 처리. 각 페이지를 보여주고, 사용자가 입력한 데이터를 Service 계층으로 전달하는 역할.

business Layer (Service)

ParcelService.java: 소포 등록, 조회, 상태 변경, 삭제 등 실제 비즈니스 로직을 수행.

data access Layer (Repository)

ParcelRepository.java: JpaRepository를 상속받아 데이터베이스와 직접 통신.

domain & dto

Parcel.java (Entity): 데이터베이스 테이블과 매핑되는 객체.

Status.java (Enum): PENDING, IN_TRANSIT, DELIVERED 같은 배송 상태 값을 정의.

ParcelDto.java (DTO): 계층 간 데이터 전송을 위한 객체.