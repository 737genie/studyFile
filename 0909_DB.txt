1. 동시성 제어(Concurrency Control)
- 여러 트랜잭션(작업 단위)이 동시에 db에 접근할 때, 데이터의 일관성 및 정합성
유지를 위해 필요함. 충돌 예방.
- 동시성 제어를 사용하는 이유 : 충돌없이 최대한 많은 작업 빠르게처리(효율성증대) 
			    >> 시스템 생산성 극대화

2. 발생 가능성이 있는 충돌 3가지
1) Dirty Read - 커밋되지 않은 데이터를 다른 트랜잭션이 읽음
	    - 만약 데이터가 롤백(수정 취소)되면 '다른 트랜잭션'이 
	       잘못된 데이터를 보고 작업할 가능성이 있음
해결방안 : READ COMMITTED 이상의 격리수준

2) Non-Repeatable Read - 한 트랜잭션 내에서 같은 데이터를 두번 읽었을때
		         그 사이에 다른 트랜잭션이 데이터 수정 및 커밋했을때 발생
해결방안 : REPEATABLE READ 이상의 격리수준

3) Phantom Read - 2번과 유사하지만 데이터의 범위가 좁음 (데이터의 행 조회 결과가 달라짐)

해결방안 : SERIALIZABLE 격리수준 사용 or 일부 DBMS에서는 Next-Key Lock으로 해결

3. 충돌 해결 방법 : Lock , Isolation

1) Lock : 어떤 트랜잭션이 데이터를 사용 중이므로 다른 것의 접근을 제어

1)-1. Shared Lock(공유 잠금) : 데이터 읽기만 할 때 사용 (다른 트랜잭션이 읽는건 허용)
1)-2. Exclusive Lock(배타적 잠금) : 데이터 수정 및 삭제 시 사용 (아예 접근을 막음)

2) Isolation : 트랜잭션 간 독립성을 어느정도로 엄격하게 적용할 건지 정함
- 단, 격리 수준이 높을수록 정합성은 올라가는 반면 동시성은 떨어지기 때문에
   성능 저하 이슈 있음

4. Isolation의 4단계 수준

1) READ UNCOMMITTED (level 0)
	특징 : 어떤 잠금도 적용하지 않음
	문제 : 3가지 충돌문제가 모두 발생할 수 있음

2) READ COMMITTED (level 1)
	특징 : 커밋된 데이터만 읽음, 오라클 계열 기본 격리 수준
	해결 : 더티리드 방지

3) REPEATABLE READ (level 2)
	특징 : 트랜잭션 시작 시점의 데이터 버전을 계속 유지하여 보여줌
	해결 : 1,2번 문제 방지 
	문제 : MySQL 계열 기본 격리 수준, 
	         이 계열은 Next-Key Lock을 통해 팬텀리드도 방지 가능

4) SERIALIZABLE (level 3)
	특징 : 가장 엄격한 수준, 트랜잭션들을 순서대로 직렬화 하여 처리
	해결 : 모든 동시성 문제 해결
	문제 : 동시성이 거의 없어지므로 성능 저하 이슈 있음


5. DeadLock

1) 발생 조건 - 상호 배제, 점유 대기, 비선점, 순환 대기 4가지 조건을 모두 충족

2) 조건의 특징
- 상호 배제 : 한번에 오직 하나의 트랜잭션만 특정 자원을 독점적 사용
- 점유 대기 : 자원을 하나 이상 점유한 상태에서 다른 트랜잭션이 점유한 자원을 얻기위해 대기
- 비선점 : 다른 트랜잭션이 점유한 데이터를 강제로 뺏을 수 없음
- 순환 대기 : 트랜잭션들이 자원 점유, 대기 관계를 형성하여 꼬리물기 한 상태

3) 감지 방법 : DBMS가 주기적으로 트랜잭션 상태를 검사하여 확인

4) 해결 방법 
	데드락 감지 > 희생자 선택 > 강제 롤백 > 재시도

희생자 선택 기준 : 롤백 비용이 적은 트랜잭션 희생

5) 데드락 최소화 하려면...
	- 트랜잭션이 잠금을 얻는 순서를 통일하는 등 프로그래밍 적 노력도 필요